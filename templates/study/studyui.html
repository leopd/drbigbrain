{% extends "djbase.html" %}

{% block dj_header_extra %}

<style type="text/css">
    .box {
        margin-top: 10px;
        color: #292929;
        width: 300px;
        border: 1px solid #BABABA;
        background-color: #ddd;
        padding-left: 10px;
        padding-right: 10px;
        margin-left: 10px;
        margin-bottom: 1em;
        -o-border-radius: 10px;
        -moz-border-radius: 12px;
        -webkit-border-radius: 10px;
        -webkit-box-shadow: 0px 3px 7px #adadad;
        border-radius: 10px;
        -moz-box-sizing: border-box;
        -opera-sizing: border-box;
        -webkit-box-sizing: border-box;
        -khtml-box-sizing: border-box;
        box-sizing: border-box;
        overflow: hidden;
    }

    .qacard {
	font-size: 30px;
        border: 1px solid #BABABA;
	margin: 10px;
	padding: 5px;
    }

    .uihints {
	margin-top: 20px;
	font-size: 8px;
    }

    .statusbar {
	margin-top: 20px;
	background-color: #eed;
    }

    .debugbar {
	margin-top: 20px;
	background-color: #edd;
	font-size: 9px;
	display:none;
    }

    .answerbutton {
	width: 100px;
	height: 25px;
	margin: 4px;
    }
</style>


<script type="text/javascript">
    /////////////////////////////////////////////////////////
    //
    // timer, Q&A UI, buttons
    //
    /////////////////////////////////////////////////////////

    function debugPrint(msg) {
	// console.dir(msg);
    }


    var start_time_ms;
    function start_timer() {
	var d = new Date();
	start_time_ms = d.getTime(); // ms since 1970
    }

    function time_elapsed_ms() {
	var d = new Date();
	return d.getTime() - start_time_ms;
    }


    // remembers how long btx card display and show button being pressed
    var showtimer_ms=-1; 

    function showAnswer()
    {
	showtimer_ms= time_elapsed_ms();
	dojo.byId("answerDiv").style.display="block";
	dojo.byId("showButton").blur();
	dojo.byId("showButton").style.display="none";
    }

    function hideAnswer()
    {
	dojo.byId("answerDiv").style.display="none";
	dojo.byId("showButton").style.display="block";
    }



    var cardId; // id of the currently displayed card to be sent back with the current impression

    // just updates the q and a divs in the display.
    // nothing else.
    function showQA(q,a) {
	dojo.byId("questionContents").innerHTML= q;
	dojo.byId("answerContents").innerHTML= a;
    }

    // Shows the question, and resets the UI
    function startQuestion(qaobj) {
	// Unpack the JSON object from the server
	q = qaobj.question;
	a = qaobj.answer;
	id = qaobj.id;

	// Use it.
	showQA(q, a);
	cardId = id;
	dojo.byId("showButton").focus();
	start_timer();
    }


    var statusMsgs = {};
    // "type" allows the status bar to display multiple messages
    // and for a caller to clear one message without clearing the
    // whole thing
    function showStatus(type,msg) {
	statusMsgs[type]=msg;
	debugPrint("status of "+type+":"+msg);
	var str="";
	for(var i in statusMsgs) {
	    submsg = statusMsgs[i];
	    if( submsg ) {
		str += statusMsgs[i];
		str += "<br/>";
	    }
	}
	dojo.byId("statusbar").innerHTML = str;
    }

    /////////////////////////////////////////////////////////
    //
    // Communicating with the server
    //
    // Two parts: READING & WRITING
    //
    /////////////////////////////////////////////////////////


    /////////////////////////////////////////////////////////
    //
    // READING: asking the server for content 
    //
    // Keeps a local cache of Question & Answer objects.
    // Serves them up to the user as they're needed.
    // Uses a low-water mark method to know when it needs to
    // fetch more.
    //
    // We don't need to serialize this because these requests
    // are guaranteed by the server not to have any side-effects.
    //
    // The external interface here is just nextQA() which says
    // put up a new card, however you need to do it.
    // It tries to do it right away, else it sets it up to happen
    // async.  It also takes the opportunity to refresh the cache
    // if needed.
    /////////////////////////////////////////////////////////


    // This is called whenever it's time to display a new QA.
    // It takes care of making that happen.  
    // It will happen synchronously if possible, else async.
    function nextQA() {
	debugPrint("nextQA");
	// See if we can handle the request from local cache
	if( QACache.length > 0 ) {
	    // Handle locally
	    debugPrint("Using local");
	    var qa = QACache.shift();
	    QACacheSeq += 1;
	    startQuestion(qa);
	    displayUpdated=true;
	    userWaitingForQuestion=false;
	} else {
	    // Not enough locally.  Show waiting status.
	    // Don't need to kick off a request here.
	    // That happens below.
	    showQA("...","...");
	    userWaitingForQuestion=true;
	}

	if( QACache.length < minQABeforeFetch) {
	    // Stack is below threshhold so we need to trigger a fetch.
	    fetchMoreQA();
	    // dont worry about de-duping requests.  
	    // fetchmoreqa will do that.
	}
	debugCache();
    }

    //
    // Should make a CardCache class for all that follows
    // Even without, it should be encapsulated to this section of code.
    //

    // configuration parameters
    var numQAToFetch = 6;
    var minQABeforeFetch = 3; // the low water mark below which we fetch more

    // retry counter
    var fetchErrorCount = 0;


    // Global state about the QA Cache and the display
    var fetchingMore=false; // True if there's an outstanding request.
    var userWaitingForQuestion=true; // so we can show it

    // the local cache of QA objects.  It's an array of json objects
    var QACache = []; 
    // The sequence number of the first object in the cache
    var QACacheSeq = -1;

    // Renders a cache object for debugging as HTML
    function renderDebugCache(cache) {
	var str = "<B>Cache State:</B><br/>";
	str += "Seq = " + QACacheSeq + "<br/>"
	str += "<ul>"
	for(var i=0; i<cache.length; i++) {
	    obj = cache[i];
	    str += "<li>";
	    str += obj.question+" ("+obj.id+")";
	    str += "</li>";
	}
	str += "</ul>";
	if( userWaitingForQuestion ) {
	    str += "<B>USER WAITING</B><br/>";
	}
	if( fetchingMore ) {
	    str += "<i>FETCHING...</i><br/>";
	}
	return str;
    }

    function debugCache() {
	var cache = QACache;
	var str = renderDebugCache(cache);
	dojo.byId("debugcache").innerHTML = str;
    }

    // Asks the server for more QA data.
    // if needToUpdateUI is true then it will push the results
    // on the screen as soon as they're back.
    function fetchMoreQA() {
	// Check global state variable to de-dupe these requests
	if( fetchingMore ) {
	    // Just wait for the last one to finish.
	    return;
	}
	fetchingMore = true;
        posturl = "/study/getqa-" + numQAToFetch;

	// Check for the "revisit" hack
	if( location.hash ) {
	    // Remove the hash character
	    cardnum = location.hash.substring(1);
	    // This is not terribly robust since if the fragment
	    // is not a number, this will fail to return
	    posturl = "/study/jsoncard/"+cardnum;
	    location.hash="";
	}

	debugPrint("Fetching QA from "+posturl);

	// Kick off the request
	//
	// Why GET instead of POST?
	// Short answer: work around Android G1 browser bugs.
	// Longer answer: On G1, if you post without specifying
	// any postdata, it doesn't set the content-length
	// header, which triggers mod_security to block the request
	// with 503.  If you do set the postdata to something small
	// and static, it doesn't seem to run the load: function
	// at least not here.  Go figure.
	dojo.xhrGet( {
	    url: posturl,
	    handleAs: "json",
	    load: function(responseObject, ioArgs) {
		// When it comes back, just replace the old stack
		debugPrint("got more");
		showStatus("fetch","");
		mergeMoreQAIntoCache(responseObject)

		// reset global state.
		fetchingMore = false;
		fetchErrorCount = 0;

		// Cycle back to nextQA if the user is waiting
		if( userWaitingForQuestion ) {
		    nextQA();
		    // That will clear the userWaiting flag
		}
		debugCache();

	    },
	    error: function(error) {
		fetchingMore = false;
		debugPrint("error fetching cards: "+error);
		fetchErrorCount += 1;
		if( fetchErrorCount < 3 ) {
		    showStatus("fetch","Error fetching cards. Retrying.");
		    fetchMoreQA();
		} else {
		    showStatus("fetch","Error fetching cards. Giving up.");
		}
	    }
	});
    }


    // Line up sequence number on the response with
    // the cache's sequence number to avoid showing the
    // user the same card repeatedly.
    function mergeMoreQAIntoCache(newdata) {
	debugPrint("merging...");

	if( typeof(newdata.length) == "undefined" ) {
	    // A single object came back.  
	    // hash-hack
	    newseq=-1;
	    newdata = [newdata];
	} else {
	    newseq = newdata.shift();
	}

	// Render debug output
	var str = "<b>Incoming...</b><br/>";
	str += "newseq = " + newseq + "<br/>";
	str += renderDebugCache(newdata);
	dojo.byId("debugcache2").innerHTML= str;
	//alert("what now?");

	// Discard items from the newdata until the sequence
	// numbers line up
	while( newseq < QACacheSeq ) {
	    newdata.shift();
	    newseq++;
	}

	// Now we can merge them
	QACache = newdata;
	QACacheSeq = newseq; // This has an effect on first load
    }

    /////////////////////////////////////////////////////////
    //
    // WRITING: Submitting the impression
    //
    // The session-state on the server is not thread-safe.
    // If we send multiple overlapping requests, it will 
    // lose data since each request loads the sesison state
    // from the database into memory and then writes it back.
    // So we need to serialize the requests that will modify the
    // learning model's state.
    //
    // The server guarantees that card-read requests will not
    // modify the model's state, so we don't need to serialize
    // those against the impression logging.
    //
    // But we do need to serialize the impression logging
    // since the user might be able to answer faster than the
    // server can accept the answers.  
    //
    // TODO: Consider batching together multiple impression posts
    // if the server is having trouble keeping up.  This would minimize
    // lots of overhead on the server like model read/write.
    /////////////////////////////////////////////////////////

    // Outside interface - puts together the impression data.
    // Sends it up if possible, or else queues it up to go later.
    function submitAnswer(yesno)
    {
	var submittimer_ms = time_elapsed_ms() - showtimer_ms;

	//Should find a cleaner way to assemble the postdata
	data = "";
	data += "answer=" + yesno;
	data += "&id=" + cardId;
	data += "&showtimer=" + showtimer_ms;
	data += "&submittimer=" + submittimer_ms;

	postOrQueueImpression(data);

	// Deal with the rest of the UI
	hideAnswer();
	nextQA();
    }


    //
    // What follows should be encapsulated into a class
    //

    // The list of impressions waiting to post
    var postQueue=[];
    // Are we currently waiting for an impression post to return?
    var waitingForImpressionPost = false;

    function postOrQueueImpression(data)
    {
	postQueue.push(data);
	debugPrint("Pushed post.  queue="+ postQueue.length);
	launchPostIfAppropriate();
    }

    // If we have data queued to go, and there isn't an XHR already
    // outstanding, then we launch a new XHR
    function launchPostIfAppropriate() {
	debugPrint("launch post? queue="+ postQueue.length);
	if( waitingForImpressionPost ) {
	    // Already a post outstanding.
	    return;
	}

	if( postQueue.length < 1 ) {
	    debugPrint("Nothing to post");
	    // Nothing to post
	    return;
	}
	debugPrint("yes! launch post!");

	// Set up the XHR
	data = postQueue.shift();

	var xhrArgs = {
	    url: "/study/impression",
	    postData: data,
	    handleAs: "text",
	    load: function(result) {
		waitingForImpressionPost = false;
		debugPrint("impression posted: "+data);
		showStatus("post","");
		launchPostIfAppropriate();
	    },
	    error: function(error) {
		waitingForImpressionPost = false;
		debugPrint("Error submitting impression: "+error);
		showStatus("post","Error posting answer");
		// TODO: retry to submit this impression
	    }
	};
	waitingForImpressionPost = true;
	dojo.xhrPost(xhrArgs);
	showStatus("post","Submitting answer...");
    }
    
    /////////////////////////////////////////////////////////
    //
    // Dojo startup stuff
    //
    /////////////////////////////////////////////////////////

    // load required modules
    dojo.require("dojo.parser");

    dojo.addOnLoad(function(){
	wireKeyboardEvents();
		
	startUI();
    });

    function wireKeyboardEvents() {
	var node = dojo.byId("bodytag");
	dojo.connect(node, "onkeypress", function(e){
	    switch(e.charOrCode){
		case 's':
		case 'S':
		    showAnswer();
		    break;
		case 'n':
		case 'N':
		    submitAnswer('No');
		    break;
		case 'y':
		case 'Y':
		    submitAnswer('Yes');
		    break;
		case 'd':
		case 'D':
		    submitAnswer('Discard');
		    break;
		case 'k':
		case 'K':
		    submitAnswer('Kinda');
		    break;
	    }
	    // if you want to cancel default processing...
	    // dojo.stopEvent(e);
	});
    }
		    
    function startUI() {
	nextQA();
    }



</script>

{% endblock %}
{% block content %}
<div id="questionDiv" class="box">
What does this mean?

<div id="questionContents" class="qacard">
<i>loading...</i>
</div>
</div>
<button id="showButton" class="answerbutton" onClick="javascript:showAnswer();">Show Answer</button>
<div id="answerDiv" class="box" style="display:none" >
<div id="answerContents" class="qacard" >
<i>loading...</i>
</div>
Did you know this one?<br/>
<button id="yesButton" class="answerbutton" onClick="submitAnswer('Yes');">Yes</button>
<button id="noButton" class="answerbutton" onClick="submitAnswer('No');">No</button>
<button id="discardButton" class="answerbutton" onClick="submitAnswer('Discard');">Discard</button>
<button id="kindaButton" class="answerbutton" onClick="submitAnswer('Kinda');">Kinda</button>
</div>

<div class="uihints">
Hint:
Try pressing S, N, Y, D, K keys.
<br/>
<a href="deck">Manage your deck</a>
</div>
<div id="statusbar" class="statusbar">
</div>
<div id="debugcache" class="debugbar">
emtpy cache
</dIV>
<div id="debugcache2" class="debugbar">
</dIV>
{% endblock %}

